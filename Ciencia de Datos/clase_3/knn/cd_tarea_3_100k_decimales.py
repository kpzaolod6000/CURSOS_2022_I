# -*- coding: utf-8 -*-
"""CD_tarea_3_100k_decimales.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mCaKtMqDG5gLshKoJbxkiet5D6lTgtkQ

## Importando librerias
"""

import pandas as pd
import numpy as np
import math
from google.colab import drive
from time import time
from decimal import Decimal

"""## Leendo el data

"""

drive.mount ("/content/gdrive")
data_ratings = pd.read_csv(r'gdrive/My Drive/Colab Notebooks/topicos de Ciencia de datos/data100k/ratings.csv')

data_ratings

#data_ratings.sort_values(by=['movieId'])

# data_tags = pd.read_csv('gdrive/My Drive/Colab Notebooks/topicos de Ciencia de datos/data100k/tags.csv')

"""## Distancia Manhattan"""

def Manhattan(x1,x2):
  sum = Decimal('0.0')
  len_ = len(x1)
  for i in range(len_):
    if(not pd.isnull(x1[i]) and not pd.isnull(x2[i])):
      sum += abs(Decimal(str(x1[i])) - Decimal(str(x2[i])))
      #print(abs(x1[i] - x2[i]))
  return sum

"""## Distancia Euclideana"""

def Euclidiana(x1,x2):
  sum = Decimal('0.0')
  len_ = len(x1)
  for i in range(len_):
    if(not pd.isnull(x1[i]) and not pd.isnull(x2[i])):
        sum += (Decimal(str(x1[i])) - Decimal(str(x2[i])))**Decimal('2')
  return Decimal(str(math.sqrt(sum)))

"""## Correlacion de Pearson"""

def Pearson(x,y):
  n_Reg = len(x)
  
  x_y = Decimal('0.0') # x*y
  s_x = Decimal('0.0') # sumatoria(x)
  s_y = Decimal('0.0') # sumatoria(y)
  s_x2 = Decimal('0.0') ## sumatoria de cuadrados(x)
  s_y2 = Decimal('0.0') ## sumatoria de cuadrados(x)
  n = Decimal('0.0')
  for i in range(n_Reg):
    if(not pd.isnull(x[i]) and not pd.isnull(y[i])):
      n += 1
      x_y += (Decimal(str(x[i])) *  Decimal(str(y[i])))
      s_x += Decimal(str(x[i]))
      s_y += Decimal(str(y[i]))
      s_x2 += Decimal(str(x[i]))**Decimal('2')
      s_y2 += Decimal(str(y[i]))**Decimal('2')

      #print(x[i],' * ', y[i] ,' : ',x_y)
        

  s_x_s_y = (s_x * s_y)/n # sumatoria(x*y)/n
  s_x2N = (s_x**Decimal('2'))/n # sumatoria de X al cuadrado sobre n
  s_y2N = (s_y**Decimal('2'))/n # sumatoria de Y al cuadrado sobre n
  
  #print(s_x_s_y)
  #print(s_x2N)
  #print(s_y2N)
  if((Decimal(str(math.sqrt(s_x2 - s_x2N))) * Decimal(str(math.sqrt(s_y2 - s_y2N)))) == 0):
    r = 0
  else:
    r = (x_y - s_x_s_y) / (Decimal(str(math.sqrt(s_x2 - s_x2N))) * Decimal(str(math.sqrt(s_y2 - s_y2N))))
  return r

"""## Similitud del Coseno"""

def Coseno(x,y):
  n_Reg = len(x)
  x_y = Decimal('0.0')
  x2 = Decimal('0.0')
  y2 = Decimal('0.0')
  for i in range(n_Reg):
    if(not pd.isnull(x[i]) and not pd.isnull(y[i])):
      x_y += Decimal(str(x[i])) * Decimal(str(y[i]))
      x2 += Decimal(str(x[i]))**Decimal('2')
      y2 += Decimal(str(y[i]))**Decimal('2')

  # print(x_y)
  # print(math.sqrt(x2))
  # print(math.sqrt(y2))
  cos_ = (x_y)/(Decimal(str(math.sqrt(x2))) * Decimal(str(math.sqrt(y2))))
  return cos_

"""# Secci√≥n 2
## KNN 
### Pruebas en la data de 100 000 Ratings

### Columnas
"""

columns_names = list(data_ratings.columns.values)
columns_names = columns_names[:]
columns_names

"""### Algoritmo Knn 

"""

#del data["X"]

def Knn(data,user,metric,nro_user):

  distances = []
  n_users = data['userId'].unique()
  data_user = data[data['userId'] == user]
  data_user = data_user[['movieId','rating']]


  for x_user in n_users:
    if x_user != user:
      data_x_user = data[data['userId'] == x_user][['movieId','rating']]
      # column_movieId = [data_user.iloc[i,0] for i in range(len(data_user['movieId'])) if data_user.iloc[i,0] in data_x_user['movieId']]
      column_movieId = np.intersect1d(data_user['movieId'],data_x_user['movieId'])
      
      
      rating_x_user= []
      rating_user= []
      for id in range(len(column_movieId)):
        c = [data_x_user.iloc[g,1] for g in range(len(data_x_user['movieId'])) if data_x_user.iloc[g,0]  == column_movieId[id]]
        rating_x_user.append(c[0])
        d = [data_user.iloc[g,1] for g in range(len(data_user['movieId'])) if data_user.iloc[g,0]  == column_movieId[id]]
        rating_user.append(d[0])
      
      if(len(rating_user) != 0):
        d = metric(np.array(rating_x_user),np.array(rating_user))
        distances.append((x_user,d))
      # print("user")
      # print(rating_user)
      # print(rating_x_user)
      # #print(column_movieId)
  distances.sort(key=lambda artistTuple: artistTuple[1], reverse=False) # lambda artistTuple invoca los elementos que tienen en distances

  return distances[:nro_user]

def Knn2(data,user,metric,nro_user):

  distances = {}
  n_users = data['userId'].unique()
  data_user = data[data['userId'] == user]
  data_user = data_user[['movieId','rating']]


  for x_user in n_users:
    if x_user != user:
      data_x_user = data[data['userId'] == x_user][['movieId','rating']]
      # column_movieId = [data_user.iloc[i,0] for i in range(len(data_user['movieId'])) if data_user.iloc[i,0] in data_x_user['movieId']]
      column_movieId = np.intersect1d(data_user['movieId'],data_x_user['movieId'])
      
      
      rating_x_user= np.array([])
      rating_user= np.array([])
      for id in column_movieId:
        rating_x_user = np.append(rating_x_user,float (data_x_user[data_x_user['movieId'] == id]['rating']))
        rating_user = np.append(rating_user,float (data_user[data_user['movieId'] == id]['rating']))
      
      if(len(rating_user) != 0):
        d = metric(rating_x_user,rating_user)
        if math.isnan(d):
          d = 0
        #print(d)
        distances[x_user] = d
      # print("user")
      # print(rating_user)
      # print(rating_x_user)
      # #print(column_movieId)
  closest_k = sorted(distances.items(), key = lambda x:x[1],reverse = True)

  return closest_k[:nro_user]

# start_time = time()
# print(Knn(data_ratings,1,Pearson,3))
# elapsed_time = time() - start_time
# print("Tiempo transcurrido: %0.10f milisegundos." % (elapsed_time * 1000))

start_time = time()
print(Knn2(data_ratings,1,Pearson,3))
elapsed_time = time() - start_time
print("Tiempo transcurrido: %0.10f segundos." % (elapsed_time))

"""## Pruebas con librerias
### Distancia Manhattan
"""

from scipy.spatial.distance import cityblock
def Manhattan_lib(x1,x2):
  return cityblock(x1, x2)

"""
### Distancia Euclidiana"""

from scipy.spatial.distance import euclidean
def Euclidiana_lib(x1,x2):
 return euclidean(x1,x2)

"""### Distancia Correlacion de Pearson"""

def Pearson_lib(x1,x2):
  #print(np.corrcoef(x1, x2)[0,1])
  return np.corrcoef(x1, x2)[0,1]

"""### Distancia Similitud de coseno"""

from scipy import spatial
def Coseno_lib(x1,x2):
  return 1 - spatial.distance.cosine(x1,x2)

"""### pruebas de knn"""

start_time = time()
print(Knn2(data_ratings,1,Pearson_lib,3))
elapsed_time = time() - start_time
print("Tiempo transcurrido: %0.10f segundos." % (elapsed_time))

# df = pd.read_csv(r"gdrive/My Drive/Colab Notebooks/topicos de Ciencia de datos/data100k/ratings.csv",sep=",", header=None, names=['userId','movieId','ratings','timestamp'])
# df_formatted = df.pivot_table(index='movieId', columns='userId', values='ratings')
# df_formatted

1.2 / 1.5

Decimal('1.2') - Decimal('1.0')

